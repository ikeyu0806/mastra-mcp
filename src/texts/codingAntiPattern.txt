## 命名に関するアンチパターン
| アンチパターン例                               | 内容                                | 改善例                                             |
| -------------------------------------- | --------------------------------- | ----------------------------------------------- |
| data, info, temp, flg などの曖昧な名前 | 変数名から意味が分からない                     | userList, isEmailValid, temporaryUserName |
| 略語の多用 (cnt, val, ctx)            | 文脈によって意味が変わる可能性あり                 | count, value, context                     |
| 一貫性のない命名規則                             | 命名が camelCase、snake_case 混在など | プロジェクト内で統一（例：全て snake_case）                   |
| 数字付き命名（例: user1, user2）            | 意味が伝わらずスケーラビリティがない                | 配列やリストを使用し、users[0], users[1] などに           |

## マジックナンバーの使用
悪い例

if score > 85:
    grade = "A"

良い例

GRADE_A_THRESHOLD = 85
if score > GRADE_A_THRESHOLD:
    grade = "A"


## コード構造に関するアンチパターン
1. 長すぎる関数 / メソッド（God Function）
100行超え、複数の責務を持つ関数は保守困難。

改善: 単一責任の原則に従って分割する。

2. コピペプログラミング（DRY違反）
同じ処理を複数箇所にコピペ → 修正漏れの原因。

改善: 関数化・共通化して1箇所にまとめる。

3. グローバル変数の乱用
状態の追跡が難しくなり、バグの温床に。

改善: スコープを狭める、クラス・関数内に閉じる。

## エラー処理のアンチパターン
| アンチパターン                           | 内容                    | 改善策                                             |
| --------------------------------- | --------------------- | ----------------------------------------------- |
| エラー無視 (try { ... } catch(e) {}) | 問題に気づけない              | console.error(e) やログ出力                        |
| 曖昧な例外メッセージ                        | "Error occurred" など | "Failed to fetch user data from API" のように具体的に |
| catchブロックで何でも握りつぶす                | 予期せぬエラーまで吸収してしまう      | 例外を再スロー、ログ記録、区別処理                               |

## 制御構文のアンチパターン
1. 複雑すぎるネスト（ネスト地獄）
python
コピーする
編集する
if a:
    if b:
        if c:
            # 処理
改善: 早期リターン（guard clause）でシンプルに

2. 多すぎる if-else チェーン
if x == 1 ... elif x == 2 ... elif x == 3...

改善: dict でのディスパッチ、ポリモーフィズム

## テストに関するアンチパターン
テストがない / 曖昧すぎるテスト名（例：test1()）

複数のアサートを混在させる

状態に依存するテスト（前のテストの副作用が次に影響）

## コードの再利用性・可読性のアンチパターン
ハードコーディングされたパスや設定値

/usr/local/app/config.txt → 定数や環境変数に切り出す

コメントで説明が必要なほど複雑な処理

コメントではなく処理自体を関数で分割

## オブジェクト指向設計におけるアンチパターン
God Object（すべてを知っているクラス）

Setter/Getter地獄（ロジックのないデータクラス）

継承の乱用 → コンポジションで代替可能

依存性注入なしでの密結合

## 引数が多すぎる

可読性の低下:
- 関数やメソッドを読むときに、何をしているのかが分かりにくくなる。
- 呼び出し側でも、どの引数がどの意味を持つのか把握しづらくなる。

保守性の低下:
- 引数の順番変更、追加・削除が他のコードにも影響を及ぼす。
- テストやデバッグ時に、全ての引数を準備する必要がある。

再利用性の低下:
- 特定のコンテキストに依存した関数になりやすく、他の場面で使いにくい。

悪い例:
function createUser(name: string, age: number, email: string, address: string, phone: string) {
  // ...
}

良い例:
type UserInfo = {
  name: string;
  age: number;
  email: string;
  address: string;
  phone: string;
};

function createUser(user: UserInfo) {
  // ...
}

## 技術駆動命名

概要:
変数や関数名が「data」「flg」「res」「obj」など、技術的な汎用語や省略語になっており、意味や意図がコードから読み取れない状態。

問題点:
- 変数の役割や中身が不明確
- ドメイン知識が伝わらず、可読性・保守性が低下
- 命名の一貫性がなく、初見の人には理解しづらい

悪い例:
const data = fetchUser();
const flg = isValidUser(user);

良い例:
const userProfile = fetchUser();
const isUserEligibleForPromotion = isValidUser(user);

## 連番命名

概要:
変数や関数名に連番（xxx1, xxx2, xxx3...）を付けて命名することで、意味や構造が失われた状態。

問題点:
- 中身の違いが名前に表れておらず、意図が読み取れない
- データの数が増えるとメンテナンスが困難になる
- 配列やオブジェクトで扱うべきデータを、スケーラブルでない形で保持してしまう

悪い例:
const user1 = "Alice";
const user2 = "Bob";
const user3 = "Charlie";

良い例（配列で管理）:
const users = ["Alice", "Bob", "Charlie"];

良い例（意味のある名前に）:
const adminUser = "Alice";
const guestUser = "Bob";
const trialUser = "Charlie";

## その他のアンチパターン
| アンチパターン     | 内容                                |
| ----------- | --------------------------------- |
| TODOコメントの放置 | 実装予定なのにずっと未対応になる                  |
| 無駄な最適化      | 速度が求められない部分に過剰なロジック               |
| デバッグ出力の残存   | print() や console.log() の消し忘れ |